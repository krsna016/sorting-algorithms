# Sorting Algorithms in Multiple Languages

This repository contains the implementation of various sorting algorithms in multiple programming languages like Python and Java. Sorting algorithms are fundamental in computer science and are used to arrange data in a particular order, usually ascending or descending.

## üìã Table of Contents
- [About](#about)
- [List of Algorithms](#list-of-algorithms)
- [Getting Started](#getting-started)

## üåü About
This repository provides a collection of popular sorting algorithms implemented in Java. Each algorithm is accompanied by an explanation of how it works, its time and space complexities, and best/worst-case scenarios. These implementations are great for students learning sorting algorithms, interview preparation, or anyone looking to deepen their understanding of algorithm design.

## üöÄ List of Algorithms

### 1. **Bubble Sort**
- **Description**: A simple comparison-based algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order.
- **Time Complexity**:
    - Best: O(n)
    - Average: O(n¬≤)
    - Worst: O(n¬≤)
- **Space Complexity**: O(1)

### 2. **Selection Sort**
- **Description**: Continuously selects the smallest element from the unsorted portion and swaps it with the element at the current position.
- **Time Complexity**:
    - Best: O(n¬≤)
    - Average: O(n¬≤)
    - Worst: O(n¬≤)
- **Space Complexity**: O(1)

### 3. **Insertion Sort**
- **Description**: Builds a sorted array one element at a time by inserting each new element into its proper place among those already sorted.
- **Time Complexity**:
    - Best: O(n)
    - Average: O(n¬≤)
    - Worst: O(n¬≤)
- **Space Complexity**: O(1)

### 4. **Merge Sort**
- **Description**: A divide-and-conquer algorithm that divides the array into halves, recursively sorts them, and then merges the sorted halves.
- **Time Complexity**:
    - Best: O(n log n)
    - Average: O(n log n)
    - Worst: O(n log n)
- **Space Complexity**: O(n)

### 5. **Quick Sort**
- **Description**: A divide-and-conquer algorithm that picks a pivot, partitions the array around the pivot, and recursively sorts the partitions.
- **Time Complexity**:
    - Best: O(n log n)
    - Average: O(n log n)
    - Worst: O(n¬≤)
- **Space Complexity**: O(log n)

### 6. **Heap Sort**
- **Description**: Utilizes a binary heap structure to sort an array by first building the heap and then repeatedly extracting the maximum element.
- **Time Complexity**:
    - Best: O(n log n)
    - Average: O(n log n)
    - Worst: O(n log n)
- **Space Complexity**: O(1)

### 7. **Counting Sort**
- **Description**: Counts the number of occurrences of each unique element, then calculates their positions in the sorted array.
- **Time Complexity**:
    - Best: O(n + k)
    - Average: O(n + k)
    - Worst: O(n + k)
- **Space Complexity**: O(n + k)

### 8. **Radix Sort**
- **Description**: Non-comparative sorting algorithm that sorts integers by processing digits.
- **Time Complexity**:
    - Best: O(nk)
    - Average: O(nk)
    - Worst: O(nk)
- **Space Complexity**: O(n + k)

### 9. **Shell Sort**
- **Description**: A generalization of insertion sort that allows exchanges of elements that are far apart.
- **Time Complexity**:
    - Best: O(n log n)
    - Average: O(n log¬≤ n)
    - Worst: O(n¬≤)
- **Space Complexity**: O(1)

### 10. **Bucket Sort**
- **Description**: Distributes elements into several buckets, sorts the buckets, and then concatenates them.
- **Time Complexity**:
    - Best: O(n + k)
    - Average: O(n + k)
    - Worst: O(n¬≤)
- **Space Complexity**: O(n + k)

## üõ†Ô∏è Getting Started

### Prerequisites
To run the algorithms in this repository, you'll need:
- **Java JDK 8+** (for Java implementations)

### Installation
1. Clone this repository:
   ```bash
   git clone https://github.com/your-username/sorting-algorithms.git
   cd sorting-algorithms
   ```









